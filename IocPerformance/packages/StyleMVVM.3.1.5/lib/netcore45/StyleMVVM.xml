<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StyleMVVM</name>
    </assembly>
    <members>
        <member name="T:StyleMVVM.Bootstrapper">
            <summary>
            This is the base implementation for IBootstrapper. 
            It is also where the global instance of the IBootstrapper lives.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:StyleMVVM.IBootstrapper" -->
        <member name="M:StyleMVVM.IBootstrapper.Start">
            <summary>
            starts the bootstrapper and container
            </summary>
        </member>
        <member name="M:StyleMVVM.IBootstrapper.Start(System.Boolean)">
            <summary>
            starts the bootstrapper and container
            </summary>
        </member>
        <member name="M:StyleMVVM.IBootstrapper.Launched">
            <summary>
            Called when the App is launched
            </summary>
        </member>
        <member name="M:StyleMVVM.IBootstrapper.Shutdown">
            <summary>
            shuts down the boot strapper and container
            </summary>
        </member>
        <member name="P:StyleMVVM.IBootstrapper.Container">
            <summary>
            The default DI Container for the bootstrapper
            </summary>
        </member>
        <member name="M:StyleMVVM.Bootstrapper.#ctor">
            <summary>
            Default constructor registers this bootstraper as the default Instance
            and then create the container and register the default factories
            </summary>
        </member>
        <member name="M:StyleMVVM.Bootstrapper.#ctor(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Constructor where you provide the Container instead of allowing the bootstrapper to create one
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:StyleMVVM.Bootstrapper.Start">
            <summary>
            Starts the bootstrapper
            </summary>
        </member>
        <member name="M:StyleMVVM.Bootstrapper.Start(System.Boolean)">
            <summary>
            Starts the bootstrapper
            </summary>
        </member>
        <member name="M:StyleMVVM.Bootstrapper.Shutdown">
            <summary>
            Shuts the bootstrapper down
            </summary>
        </member>
        <member name="P:StyleMVVM.Bootstrapper.HasInstance">
            <summary>
            Is there an Instance created
            </summary>
        </member>
        <member name="P:StyleMVVM.Bootstrapper.InstanceIsReady">
            <summary>
            Returns true if there is a bootstrapper and it is ready
            </summary>
        </member>
        <member name="P:StyleMVVM.Bootstrapper.Instance">
            <summary>
            Default instance of the boostrapper.
            This Property will create on if one does not exist and register the main apps exports
            This is not the recommend way of doing it.
            </summary>
        </member>
        <member name="P:StyleMVVM.Bootstrapper.RegisterStyleAssembly">
            <summary>
            Should the IDependencyInjectionContainer register the StyleMVVM library for exports
            This is by default true and shouldn't be changed unless you are prepared to 
            handle all needed export types.
            </summary>
        </member>
        <member name="P:StyleMVVM.Bootstrapper.Container">
            <summary>
            The DI container for the bootstrapper
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Activation.IActivationAware">
            <summary>
            Classes that implement this interface will will have the Activate method called when the class is constructed and all imports satisfied
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationAware.Activate">
            <summary>
            Called when the class is first created and all imports have been satisfied
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Activation.ICustomInitialization">
            <summary>
            Objects that implement this interface will have the CustomInitialization method called directly after being created.
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.ICustomInitialization.CustomInitialization(StyleMVVM.DependencyInjection.IDependencyInjectionContainer,StyleMVVM.DependencyInjection.IInjectionContext)">
            <summary>
            Called directly after an object is created but before Properties are injected and MethodInjection
            </summary>
            <param name="container"></param>
            <param name="injectionContext"></param>
        </member>
        <member name="T:StyleMVVM.Data.Activation.ITypeAugmenter">
            <summary>
            This class allows you to augment the types that are produced by the activation service.
            In particular the Aspects module uses this to replace the inType with a subclassed version.
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Transform.ITransformMap">
            <summary>
            This interface allows you to map a transform between types.
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Transform.ITransformMap.IsLooseTransform(System.Boolean)">
            <summary>
            Are properties allowed to be unmapped in the transform
            </summary>
            <param name="isLoose"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Transform.ITransformMap.InType(System.Type)">
            <summary>
            Type to transform from
            </summary>
            <param name="inType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Transform.ITransformMap.OutType(System.Type)">
            <summary>
            Type to tranform to
            </summary>
            <param name="outType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Transform.ITransformMap.MapComplete">
            <summary>
            You must call this when you are done with your map.
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.Transform.ITransformMap.MapProperty">
            <summary>
            Use this to map properties between types
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Transform.ITransformService">
            <summary>
            This service offers a code free way to transform from one type to another type.
            
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.CoreExportStartOrder">
            <summary>
            
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IInjectionContext">
            <summary>
            During an injection the context contains information about the injection as well as extra data
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.DisposalScope">
            <summary>
            DisposalScope holds a set of objects waiting to be disposed when the disposal scope is disposed
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IDisposalScope">
            <summary>
            IDisposalScope represents an object that holds a set of object for disposing
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDisposalScope.AddObject(System.IDisposable)">
            <summary>
            Add an object to be disposed when the scope is done
            </summary>
            <param name="newObject"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDisposalScope.AddObject(System.IDisposable,StyleMVVM.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object to be disposed when the scope is done, it takes a delegate to be called before disposal happens
            </summary>
            <param name="newObject"></param>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.DisposalScope.DisposalScopeStringKey">
            <summary>
            Key to be used to lookup disposal scope
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportEnvironment">
            <summary>
            Defined what environement the application is running in or compenent is Exported in
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IExportActivator">
            <summary>
            This interface represents the way to activate an export, be it IExportStrategy or some other custom way of defining a value
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportActivator.Activate(StyleMVVM.DependencyInjection.IInjectionContext,System.Object[])">
            <summary>
            Activate an instance of the object
            </summary>
            <param name="injectionContext">injection context</param>
            <param name="constructorParams">parameters to pass to the constructor</param>
            <returns>instance</returns>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportActivator.Container">
            <summary>
            The activation container associated with this container
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportActivator.ActivationService">
            <summary>
            The activation service this Export should use.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IExportStrategy">
            <summary>
            IActivationStrategy provides a mechanism to instantiate a particular export
            a strategy can be exported under many names and types.
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.AddPiplineHandler(StyleMVVM.DependencyInjection.IExportPipelineHandler)">
            <summary>
            Adds a new pipeline handler to the strategy
            </summary>
            <param name="pipelineHandler"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.RemovePipelineHandler(StyleMVVM.DependencyInjection.IExportPipelineHandler)">
            <summary>
            Removes the specified pipelined handler from the strategy
            </summary>
            <param name="pipelineHandler"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.MeetsConditions(StyleMVVM.DependencyInjection.IDependencyInjectionContainer,StyleMVVM.DependencyInjection.IInjectionContext)">
            <summary>
            Test if the export meets the condition
            </summary>
            <param name="container"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.AddCondition(StyleMVVM.DependencyInjection.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.RemoveCondition(StyleMVVM.DependencyInjection.IExportCondition)">
            <summary>
            Remove a condition from the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategy.Conditions">
            <summary>
            Gets all conditions for the export
            </summary>
            <returns></returns>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.ExportedTypes">
            <summary>
            Types this strategy is exported under
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.ActivationType">
            <summary>
            Type to activate
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.ExternallyOwned">
            <summary>
            Marking an export as externally owned will tell the framework not to dispose of the export when it goes out of scope
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.DisposalCleanupDelegate">
            <summary>
            If your export implements IDisposable and is used in a IDisposalScope then this method allows you to inject cleanup logic before disposal
            The use case for this is something like closing a wcf proxy before disposing it
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.LifeCycleContainer">
            <summary>
            This is the default life cycle container for this strategy. If null then the export will be created new each time.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.Suspendable">
            <summary>
            should this object type be registered for suspension
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.IsCoreExport">
            <summary>
            True when the object being exported should be part of Core application
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.CoreExportStartOrder">
            <summary>
            The order in which the core exports should be started.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.Metadata">
            <summary>
            List of metadata associated with this strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IExportStrategy.EnrichWithDelegates">
            <summary>
            List of enrich with delegates
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IDefaultDisposalScopeProvider">
            <summary>
            Classes that implement this interface can provide a DisposalScope when CreateInjectionContext is called
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.IDefaultDisposalScopeProvider.ProvideDisposalScope">
            <summary>
            Provide a disposal scope for an injection context
            </summary>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.BeforeDisposalCleanupDelegate">
            <summary>
            This delegate is used to allow for an objects cleanup for it is disposed
            </summary>
            <param name="objectBeingDisposed"></param>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IActivationCompleteAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IBaseExportConfiguration">
            <summary>
            This interface is implemented by a class that can create an Export. To be used in the DI contianer
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IBaseExportConfiguration.GetExportStrategy">
            <summary>
            Gets the export strategy.
            </summary>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration">
            <summary>
            Represents a configuration object for an assembly
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.ExportInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.ExportTypesBasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.Excluding(System.Type)">
            <summary>
            Exclude a particular type from exporting
            </summary>
            <param name="excludeType">exclude type</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.InEnvironment(StyleMVVM.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.AndShared">
            <summary>
            Exports are to be marked as shared
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.AndSharedPermenantly">
            <summary>
            Obsolete infavor of AndSingleton
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.CoreExport(StyleMVVM.DependencyInjection.CoreExportStartOrder)">
            <summary>
            Marks all exports as Core Exports
            </summary>
            <param name="startOrder"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.When(StyleMVVM.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.Unless(StyleMVVM.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.AndCondition(StyleMVVM.DependencyInjection.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportAssemblyConfiguration.GetExportStrategies">
            <summary>
            Gets all known Export Strategies (internal method)
            </summary>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IEnrichWithAttribute">
            <summary>
            Attributes that implement will be called at discovery time to provide a EnrichWithDelegate
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.IEnrichWithAttribute.ProvideDelegate(System.Type,System.Int32@)">
            <summary>
            Provides an EnrichWithDelegate for an attributed type
            </summary>
            <param name="attributedType"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IExportAttribute">
            <summary>
            Attributes that want to be considered when looking for exports needs to implement this interface
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.Impl.IExportAttribute.ExportTypes">
            <summary>
            Exported Types for this type
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.Impl.IExportAttribute.ExportNames">
            <summary>
            Exported Name for this type
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IExportConditionAttribute">
            <summary>
            Attributes that implement this interface can provide an IExportCondition for the attributed type
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.IExportConditionAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a condition for the type provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IExportConfiguration">
            <summary>
            This interface is used to define an export.
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.InEnvironment(StyleMVVM.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndShared">
            <summary>
            Export will be shared between all callers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndSharedPermenantly">
            <summary>
            Obsolete infavor of AndSingleton
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndCachedWithAbsoluteExpiration(System.TimeSpan)">
            <summary>
            Allows you to mark this export to be cached using an absolute expire time after creation
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndCachedWithSlidingExpiration(System.TimeSpan)">
            <summary>
            Allows you to mark this export to be cached using a sliding expiration time
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportDefaultConstructor">
            <summary>
            Uses the first constructor found for importing (this recommended only when you have one constructor)
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportConstructor(System.Object)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.CoreExport(StyleMVVM.DependencyInjection.CoreExportStartOrder)">
            <summary>
            Mark this export as a Core export
            </summary>
            <param name="startOrder"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.Initialize(System.String)">
            <summary>
            Mark a property for initialization
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.Initialize(System.String,System.Object)">
            <summary>
            Mark a property for initialization with a particular value
            </summary>
            <param name="propertyName"></param>
            <param name="initalizeValue"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import
            </summary>
            <param name="propertyName">property name to import</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportProperty(System.String,System.Boolean)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="propertyName"></param>
            <param name="isRequired"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportProperty(System.String,StyleMVVM.DependencyInjection.IExportActivator,System.Boolean)">
            <summary>
            Mark a property for import and provide an IExportActivator to resolve it
            </summary>
            <param name="propertyName"></param>
            <param name="exportActivator">allows you to provide</param>
            <param name="isRequired">is the property required</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportProperty(System.String,System.Boolean,System.String)">
            <summary>
            Mark a property for imort, specify if its required and specify what export name to use
            </summary>
            <param name="propertyName"></param>
            <param name="isRequired"></param>
            <param name="exportName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a property for import
            </summary>
            <param name="methodName">property name to import</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportMethod(System.String,System.Boolean)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName"></param>
            <param name="isRequired"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ImportMethod(System.String,System.Boolean,System.String)">
            <summary>
            Mark a property for imort, specify if its required and specify what export name to use
            </summary>
            <param name="propertyName"></param>
            <param name="isRequired"></param>
            <param name="exportName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.LifeCycleContainer(StyleMVVM.DependencyInjection.ILifeCycleContainer)">
            <summary>
            Specify a custom lifecycle container for export.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.When(StyleMVVM.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.Unless(StyleMVVM.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AndCondition(StyleMVVM.DependencyInjection.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            </summary>
            <param name="required"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.DisposalCleanupDelegate(StyleMVVM.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportConfiguration.EnrichWith(StyleMVVM.DependencyInjection.EnrichWithDelegate,System.Int32)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <param name="priority">order in which to apply enrichments</param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IExportByInterfacesAttribute">
            <summary>
            This attribute interfaces can be used to denoate this type should be exports by it interfaces
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportPipelineHandler.FilterStrategiesForPipeline(System.Collections.Generic.IEnumerable{StyleMVVM.DependencyInjection.IExportStrategy})">
            <summary>
            Filters the list of export strategies that the pipeline should be applied to
            </summary>
            <param name="strategies">all strategies</param>
            <returns>all exports to apply the pipeline to</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportPipelineHandler.ProcessExport(System.Object,StyleMVVM.DependencyInjection.IExportStrategy)">
            <summary>
            Upon creating an export the process export method will be called
            </summary>
            <param name="exportedObject"></param>
            <param name="strategy"></param>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IExportMetadataAttribute">
            <summary>
            attributes that implement this interface can be used to provide 
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.IExportStrategyProviderAttribute">
            <summary>
            Attributes that implement this interface will be used tp create an export strategy 
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.IExportStrategyProviderAttribute.ProvideStrategy(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Called during export discovery, it is used to provide an export strategy for a type that is attributed
            </summary>
            <param name="exportType"></param>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ILifeCycleContainer">
            <summary>
            Classes that implement this interface can be used to manage the lifecycle of an export
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.ILifeCycleContainer.RetrieveObject(StyleMVVM.DependencyInjection.IExportStrategy,StyleMVVM.DependencyInjection.ExportLifeCycleMethod,StyleMVVM.DependencyInjection.IDependencyInjectionContainer,StyleMVVM.DependencyInjection.IInjectionContext,System.Object[])">
            <summary>
            Called by the export strategy when it needs to be located. The lifecycle container can decide how it should proceed.
            </summary>
            <param name="strategy"></param>
            <param name="exportMethod"></param>
            <param name="container"></param>
            <param name="injectionContext"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.ILifeCycleContainerProviderAttribute">
            <summary>
            Attributes that implement this interface can provide custom lifecycle containers during export discovery
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.ILifeCycleContainerProviderAttribute.ProvideContainer">
            <summary>
            Provide a new lifecycle container for the export
            </summary>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IInjectionTargetInfo">
            <summary>
            Defines properties that are specific to the property that is being imported
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IInjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IInjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IInjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportComparison">
            <summary>
            Compares to two export strategies based on the export environment of the container.
            </summary>
            <param name="exportA"></param>
            <param name="exportB"></param>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportFunction">
            <summary>
            This delegate allows you to construct export manually rather than letting the container figure out how to provide an export
            </summary>
            <param name="container"></param>
            <param name="injectionContext"></param>
            <param name="cosntructorParameters"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportConditionProviderDelegate">
            <summary>
            This delegate allows you to provide a global condition for the container
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.ExportConditionValueProviderDelegate">
            <summary>
            This delegate is called to provide an export condition value, where the condition name is the key and the condition value is defined as value
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.FilterExport">
            <summary>
            This delegate is used to filter out if an export should be included in a LocateAll
            </summary>
            <param name="exportStrategy">export to filter</param>
            <returns>true include the export, false if you do not want to include the export in the result set</returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.EnrichWithDelegate">
            <summary>
            Using this delegate you can provide custom logic to the activation process overriding 
            </summary>
            <param name="container"></param>
            <param name="injectionContext"></param>
            <param name="injectedObject"></param>
            <returns>return the initial object or return a wrapping object</returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.PermanentlySharedLifeCycleContainer">
            <summary>
            Obsolete infavor of SingletonLifeCycleContainer
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.SharedPerInjectionContainer">
            <summary>
            This is a life cycle container class that shares the export per Injection (i.e. for this activation and all it's children share the export)
            </summary>
        </member>
        <member name="T:StyleMVVM.Module.IModule">
            <summary>
            Objects that implement and export this interface will be created at startup and it's Initialize method will be called
            </summary>
        </member>
        <member name="M:StyleMVVM.Module.IModule.Initialize">
            <summary>
            After creation this method will be called. It is intended that you do any intialization you need and you can return a list
            of Uri's that will be loaded as Resource dictionaries and Merged into the Application resources.
            Note: In none XAML apps nothing is done with the URI
            </summary>
            <returns>list of resources to load into the application</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.IImportAttribute.ProvideImportInfo(System.Object)">
            <summary>
            Called to get import information out of the attribute
            </summary>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DesignTimeBootstrapper.CreateDesignTimeBootstrapper">
            <summary>
            Creates a new Design time bootstrapper if DesignModeEnabled is true
            and there isn't a bootstrapper already
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IExportStrategyFactory">
            <summary>
            When IDependencyInjectionContainerConfiguration is searching an assembly for exports
            it first tries to export the class, it then will call all registered Factories 
            to see if others wish to export it.
            Note: IExportStrategyFactory classes can not be exported they must be registered with the container manually
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IExportStrategyFactory.CreateStrategy(StyleMVVM.DependencyInjection.IDependencyInjectionContainer,System.Type,System.Collections.Generic.IEnumerable{System.Object},System.Boolean)">
            <summary>
            Create an activation strategy for the provided type
            </summary>
            <param name="container">IDepencyInjectionContainer this factory is to be used in.
            Note: when this method is called there will be no exports available. </param>
            <param name="type">type to create the strategy for</param>
            <param name="attributes">attributes on the class</param>
            <param name="alreadyExported"></param>
            <returns>activation strategy for the type if there is one.</returns>
        </member>
        <member name="T:StyleMVVM.Data.Activation.IActivationService">
            <summary>
            This service creatse and clones objects for interested parties.
            The base implementation uses cached compiled Linq Expressions for performance
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.Inject(System.Object)">
            <summary>
            Injects dependencies into an object based on it's attributes.
            </summary>
            <param name="injectObject"></param>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.Inject(StyleMVVM.DependencyInjection.IInjectionContext,System.Object)">
            <summary>
            Injects dependencies into an object based on it's attributes
            </summary>
            <param name="injectionContext"></param>
            <param name="injectObject"></param>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.CreateByType(StyleMVVM.DependencyInjection.IInjectionContext,System.Type,System.Object[])">
            <summary>
            Creates a new instance of createType
            All imports will be satisfied and message handlers registered
            </summary>
            <param name="injectionContext"></param>
            <param name="createType"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.DeepClone(System.Object)">
            <summary>
            Creates a deep clone of the specified object.
            </summary>
            <typeparam name="T">Type of object to clone</typeparam>
            <param name="cloneValue">object to clone</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.DeepCloneIntoInstance(System.Object,System.Object)">
            <summary>
            Clone one object into another.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cloneValue"></param>
            <param name="tInstance"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationService.CreateActivationStrategy(StyleMVVM.Data.Activation.IActivationTypeInfo)">
            <summary>
            Creates a new activation strategy based on the typeInfo provided.
            </summary>
            <param name="typeInfo"></param>
            <returns></returns>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationService.TypeAugmenter">
            <summary>
             Allows you to override how type is rendered.
             Must be set at startup for everything starts.
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Activation.CompiledActivationStrategy">
            <summary>
            The CompiledActivationStrategy is the heart of the DependencyInjectionContainer
            Using Linq Expressions it compiles a method that will construct an object
            using the provided parameters. 
            Then import all needed properties and Register for all messages.
            </summary>
        </member>
        <member name="T:StyleMVVM.Data.Activation.IActivationStrategy">
            <summary>
            Represents a class that can activate an object (used by the activation service.
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationStrategy.Activate(StyleMVVM.DependencyInjection.IInjectionContext,System.Object[])">
            <summary>
            Activate an instance of the object
            </summary>
            <param name="container">DI container</param>
            <param name="injectionContext">injection context</param>
            <param name="constructorParams">parameters to pass to the constructor</param>
            <returns>instance</returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.IActivationStrategy.GetActivationStrategyDelegate">
            <summary>
            Returns a delegate that will activate the strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationStrategy.Container">
            <summary>
            Container this strategy is associated with
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationStrategy.ActivationService">
            <summary>
            Activation service this strategy is associated with
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationStrategy.Suspendable">
            <summary>
            should this object type be registered for suspension
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationStrategy.RegisterHandlers">
            <summary>
            should this type be registered for messages
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.Activation.IActivationStrategy.PipelineHandlers">
            <summary>
            Are there any pipeline handlers asscoiated with this strategy
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.Activation.CompiledActivationStrategy.GenerateMethod">
            <summary>
            Generates and returns a Function that creates and satisfies imports
            using Linq Expressions to generate a very efficent delegate.
            </summary>
            <param name="importProperties"></param>
            <param name="initializeProperties"> </param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.CompiledActivationStrategy.CreateInjectionTargetSetStatement(System.Linq.Expressions.ParameterExpression,System.Type,System.Object,System.Object[])">
            <summary>
            This method sets the InjectionType property on the injectionContext
             creating statement injectionContext.InjectionType = injectionType;
            </summary>
            <param name="injectionContextParameter"></param>
            <param name="injectionType"></param>
            <param name="injectionTarget"></param>
            <param name="injectionTargetAttributes"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Data.Activation.CompiledActivationStrategy.CreateImportVariableExpression(System.Collections.Generic.List{System.Linq.Expressions.Expression},System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,StyleMVVM.DependencyInjection.IExportActivator,System.Type,System.String,System.Boolean,System.Boolean,System.Object,System.Object[])">
            <summary>
            All imports are located before the object is created. Call this method to get an import variable
            </summary>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.Data.IReflectionService">
            <summary>
            Simple service that allows the caller to access properties and call method on objects 
            the only have string names for.
            The Default implementation uses cached compiled Linq Expressions for performance reasons
            </summary>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.GetPropertyValue(System.Object,System.String)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <returns>property value</returns>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.GetPropertyValue(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <param name="index">index for final property</param>
            <param name="throwIfPathMissing">throw an exception if any part of the path is missing</param>
            <returns>property value</returns>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.SetPropertyValue(System.Object,System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
            <param name="index"></param>
            <param name="createIfPathMissing"></param>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.CallMethod(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Calls a method in the target by a specified name.
            For a method with a return type of void use T type of object
            </summary>
            <typeparam name="T">the return type of the method</typeparam>
            <param name="target">the target object</param>
            <param name="methodName">method name (can be dotted form A.B.C</param>
            <param name="throwIfPathMissing">throw an exception if part of the path is missing</param>
            <param name="parameters">parameters to the method</param>
            <returns>the value the method returns</returns>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.CreateGetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that can be used to access a property in an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <returns>new property delegate</returns>
        </member>
        <member name="M:StyleMVVM.Data.IReflectionService.CreateSetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that be used to set a property on an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <returns>new property delegate</returns>
        </member>
        <member name="T:StyleMVVM.Data.ReflectionService">
            <summary>
            This is the default implementation of the IReflectionService
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IDependencyInjectionContainerAware">
            <summary>
            Classes that implement this interface will have Container populated upon activation.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IDependencyInjectionContainerAware.Container">
            <summary>
            Dependency container context that this object was created in.
            </summary>
        </member>
        <member name="P:StyleMVVM.Data.ReflectionService.KnownTypes">
            <summary>
            List of custom types provided to the <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> when
            reading and writing session state.  Initially empty, additional types may be
            added to customize the serialization process.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.AttributedExportStrategy">
            <summary>
            The CompiledActivationStrategy is the heart of the DependencyInjectionContainer
            Using Linq Expressions it compiles a method that will construct an object
            using the provided parameters. 
            Then import all needed properties and Register for all messages.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer">
            <summary>
            This is the default implementation of IDependencyInjectionContainer.
            </summary>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IDependencyInjectionContainer">
            <summary>
            This is the base IOC Container for StyleMVVM.
            All methods are thread safe unless marked.
            It does not however handle calling IDisposable.Dispose()
            that onus falls on the consumer
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Start">
            <summary>
            Starts the DependencyInjectionContainer (nothing is offically exported till this time)
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Start(System.Boolean)">
            <summary>
            Starts the DependencyInjectionContainer (nothing is offically exported till this time)
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Launch">
            <summary>
            Called Once the UI has launched, core exports marked as UI will be created
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Shutdown">
            <summary>
            Shutsdown the DependencyInjectionContainer and all shared obects 
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.CreateInjectionContext">
            <summary>
            Creates a new IInjectionContext that contains all the current global conditions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.CreateInjectionContext(StyleMVVM.DependencyInjection.IDisposalScope)">
            <summary>
            Creates a new IInjectionContext that contains all the current global conditions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.CreateDisposableInjectionContext">
            <summary>
            Creates a new disposable injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.CreateDisposableInjectionContext(StyleMVVM.DependencyInjection.IDisposalScope)">
            <summary>
            Creates a new disposable injection context
            </summary>
            <param name="disposalScope"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.AddCondition(StyleMVVM.DependencyInjection.ExportConditionProviderDelegate)">
            <summary>
            Allows you to add a global condition to all injection contexts.
            Note: this Essentially is a short cut wrapper around AddContionValue where the value is true
            </summary>
            <param name="conditionName"></param>
            <param name="exportCondition"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.AddConditionValue(StyleMVVM.DependencyInjection.ExportConditionValueProviderDelegate)">
            <summary>
            Allows you to add a global condition value to all injection contexts
            </summary>
            <param name="exportConditionValue"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RemoveConditionValue(StyleMVVM.DependencyInjection.ExportConditionValueProviderDelegate)">
            <summary>
            Removes a condition value from the container
            </summary>
            <param name="exportConditionValue"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Inject(System.Object)">
            <summary>
            Processes an object for any Imports and statisfies them.
            </summary>
            <param name="injectionObject"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Locate(System.String,System.Object[])">
            <summary>
            Locates an object with a particular exportName.  
            </summary>
            <param name="exportName">exportName to look for</param>
            <param name="constructorParams">parameters to the constructor if there are any</param>
            <returns>returns export or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateWithContext(StyleMVVM.DependencyInjection.IInjectionContext,System.String,System.Object[])">
            <summary>
            Locate an object and specify the injection context, allowing you to have finer control over the injection process
            </summary>
            <param name="exportName"></param>
            <param name="injectionContext"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateByType(System.Type,System.Object[])">
            <summary>
            Locates an Export of a particular Type
            </summary>
            <param name="exportType">Export Type</param>
            <param name="constructorParams">parameters to the constructor if there are any</param>
            <returns>returns export or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateByTypeWithContext(StyleMVVM.DependencyInjection.IInjectionContext,System.Type,System.Object[])">
            <summary>
            Lcoate an object by type while specifying the injection context
            </summary>
            <param name="injectionContext"></param>
            <param name="exportType"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateByType(StyleMVVM.Data.TypeWrapper,System.Object[])">
            <summary>
            Locates an Export of a particular Type
            </summary>
            <param name="exportType">Export Type</param>
            <param name="constructorParams">parameters to the constructor if there are any</param>
            <returns>returns export or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByType(System.Type)">
            <summary>
            Locates all exports of Type T
            </summary>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByTypeWithContext(StyleMVVM.DependencyInjection.IInjectionContext,System.Type)">
            <summary>
            Located all exports of Type T and specify the injection context
            </summary>
            <param name="injectionContext"></param>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByTypeWithContext(StyleMVVM.DependencyInjection.IInjectionContext,System.Type,System.Collections.IList)">
            <summary>
            Locate all exports of type exportType into the out list
            </summary>
            <param name="injectionContext"></param>
            <param name="exportType"></param>
            <param name="outList"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByType(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Locates all exports of Type T
            </summary>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAll(System.String)">
            <summary>
            Lcoate all exports of name ExportName
            </summary>
            <param name="exportName">name to locate</param>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllWithContext(StyleMVVM.DependencyInjection.IInjectionContext,System.String)">
            <summary>
            Locate all export using the name specified and the injection context provided.
            </summary>
            <param name="injectionContext"></param>
            <param name="exportName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByType(System.Type,StyleMVVM.DependencyInjection.FilterExport)">
            <summary>
            Locates all exports of Type T
            </summary>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllByType(StyleMVVM.Data.TypeWrapper,StyleMVVM.DependencyInjection.FilterExport)">
            <summary>
            Locates all exports of Type T
            </summary>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAll(System.String,StyleMVVM.DependencyInjection.FilterExport)">
            <summary>
            Lcoate all exports of name ExportName
            </summary>
            <param name="exportName">name to locate</param>
            <param name="filterMethod">method that can filter the returns based on IExportStrategy</param>
            <returns>a collection of T (empty collection if none)</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateExportType(System.String)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportName">the name to locate</param>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateExportTypeByType(System.Type)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportType">the name to locate</param>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateExportTypeByType(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportType">the name to locate</param>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllExportTypes(System.String)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportName">the name to locate</param>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllExportTypesByType(System.Type)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.LocateAllExportTypesByType(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportName">the name to locate</param>
            <returns>export Type or null</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RegisterAssembly(System.Object)">
            <summary>
            Register all Exported types in an assembly
            </summary>
            <param name="assembly">assembly to register</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Register(System.Type)">
            <summary>
            Register a type for export
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Register(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Register a type for export
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RegisterExportFunction(System.Type,StyleMVVM.DependencyInjection.ExportFunction)">
            <summary>
            Register an export and the export function will be called at locate time
            </summary>
            <param name="exportType">Type to export, this is used as the type for import, initialize and Activate method</param>
            <param name="activatedType"></param>
            <param name="exportFunction">method to construct the export</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RegisterExportJS(StyleMVVM.DependencyInjection.ExportFunction)">
            <summary>
            Register an export and the export function will be called at locate time
            </summary>
            <param name="exportFunction">method to construct the export</param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RegisterFactory(StyleMVVM.DependencyInjection.IExportStrategyFactory)">
            <summary>
            Register an activatoin factory to be called when scanning assemblies.
            </summary>
            <param name="newFactory"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.UnregisterFactory(StyleMVVM.DependencyInjection.IExportStrategyFactory)">
            <summary>
            Unregister an activatoin factory.
            </summary>
            <param name="oldFactory"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.BlackListExportType(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.ProcessRegistration">
            <summary>
            This method tells the container to process all new registraion since last the last time it was called.
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.GetAllStrategies">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.GetStrategy(System.String)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.GetStrategy(System.Type)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.GetStrategies(System.String)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.GetStrategies(System.Type)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.AddStrategy(StyleMVVM.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.RemoveStrategy(StyleMVVM.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Environment">
            <summary>
            Defines what environment the IDependencyInjectionContainer is operating in
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.ActivationService">
            <summary>
             The instance of the activation service the Container is using.
            </summary>
        </member>
        <member name="P:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.Comparision">
            <summary>
            This property allows you to create your own comparison method.
            </summary>
        </member>
        <member name="E:StyleMVVM.DependencyInjection.IDependencyInjectionContainer.ResolveUnknownExport">
            <summary>
            You can handle this event to provide an export strategy for any unknown export
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.#ctor">
            <summary>
            Default Constructor for the DI container
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.GetService(System.Type)">
            <summary>
            Gets the service object of the specified type.
            </summary>
            <returns>
            A service object of type <paramref name="serviceType"/>.-or- null if there is no service object of type <paramref name="serviceType"/>.
            </returns>
            <param name="serviceType">An object that specifies the type of service object to get. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.RaiseUnknownExport(System.String,System.Type,System.Boolean,StyleMVVM.DependencyInjection.IInjectionContext)">
            <summary>
            
            </summary>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="resolveMultiple"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.LocateAllExportTypesByType(System.Type)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportType"></param>
            <returns>
            export Type or null
            </returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.LocateAllExportTypesByType(StyleMVVM.Data.TypeWrapper)">
            <summary>
            Locate the type that is exporting this name.
            </summary>
            <param name="exportName">the name to locate</param>
            <returns>
            export Type or null
            </returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.RegisterAssembly(System.Object)">
            <summary>
            Register all Exported types in an assembly
            </summary>
            <param name="assembly">assembly to register</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">assembly;cannot be null</exception>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.AddExportConfiguration(StyleMVVM.DependencyInjection.IBaseExportConfiguration)">
            <summary>
            Adds the export configuration to the container
            </summary>
            <param name="baseExportConfiguration">The base export configuration.</param>
            <exception cref="T:System.ArgumentNullException">baseExportConfiguration</exception>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.CompareValues(StyleMVVM.DependencyInjection.IExportStrategy,StyleMVVM.DependencyInjection.IExportStrategy,StyleMVVM.DependencyInjection.ExportEnvironment)">
            <summary>
            This method compares 2 export strategies in a particular environment using ExportEnvironment attributes and ExportPriority attributes
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.DependencyInjectionContainer.ActivateObject``1(StyleMVVM.DependencyInjection.IInjectionContext,StyleMVVM.DependencyInjection.IExportStrategy,System.Object[])">
            <summary>
            Activates an instance of T for a given Export name and constructor parameters
            </summary>
            <typeparam name="T"></typeparam>
            <param name="strategy"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.DependencyInjection.IGenericActivationStrategy">
            <summary>
            This class represnets an open generic strategy that will be used to 
            close and create another strategy.
            </summary>
        </member>
        <member name="M:StyleMVVM.DependencyInjection.Impl.GenericExportStrategy.FindClosedPropertyInfos(System.Type,StyleMVVM.DependencyInjection.Impl.InstanceExportStrategy)">
            <summary>
            This method goes through the imported properties and finds the property info's for the closed type 
            The current property infos are open
            </summary>
            <param name="closedType"></param>
            <param name="exportStrategy"></param>
            <param name="propertyInfos"></param>
        </member>
        <member name="T:StyleMVVM.Logging.ILogAppender">
            <summary>
            This interface can be implemented and exported by a class that wants to participate in the logging subsystem as a consumer of log entries
            </summary>
        </member>
        <member name="M:StyleMVVM.Logging.ILogAppender.Configure">
            <summary>
            Configure is called at application startup time
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Logging.ILogAppender.Flush">
            <summary>
            Flush is called when the logging service is being forced to flush. The intention is that you flush any message buffers you have.
            </summary>
        </member>
        <member name="M:StyleMVVM.Logging.ILogAppender.Log(StyleMVVM.Logging.LogEntry)">
            <summary>
            Log method called when a log statement is recorded to the logging service. 
            This method must be quick as it is run on which ever thread is calling log
            </summary>
            <param name="entry"></param>
        </member>
        <member name="P:StyleMVVM.Logging.ILogAppender.LoggingLevel">
            <summary>
            The general log level the log service is set at.
            </summary>
        </member>
        <member name="T:StyleMVVM.Logging.ILogService">
            <summary>
            This interface is implemented and exported by classes wanting to extend the logging infrastructure at the log service level
            </summary>
        </member>
        <member name="M:StyleMVVM.Logging.ILogService.GetLogger(System.String)">
            <summary>
            Called by Logger to fetch a ILog class for specific logger name
            </summary>
            <param name="loggerName">logger name to locate</param>
            <returns>ILog instance</returns>
        </member>
        <member name="T:StyleMVVM.Messenger.DispatchedMessenger">
            <summary>
            This class provides the default implementation for IDispatchedMessenger. 
            It also includes an IDispatchedMessenger singleton instance that is resolved using the IoC container
            </summary>
        </member>
        <member name="T:StyleMVVM.Messenger.IDispatchedMessenger">
            <summary>
            IDispatchedMessenger allows you to send messages between loosely coupled consumers.
            Note: The default implementation of DispatchedMessenger uses WeakActions to call back consumers
            so there is no need to unregister for garbage collection reasons.
            </summary>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.Send(System.Object)">
            <summary>
            Sends a message of Type T to consumers.
            </summary>
            <param name="message">message to send, cannot be null</param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.Register(System.Object)">
            <summary>
            Registers an action as a consumer of type T messages.
            </summary>
            <typeparam name="T">message Type</typeparam>
            <param name="callback">message handler</param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.Register(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Registers an action as a consumer of type T messages.
            </summary>
            <typeparam name="T">message Type</typeparam>
            <param name="callback">message handler</param>
            <param name="background">should it be called back on a background thread</param>
            <param name="holdReference"> </param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.RegisterMethod(System.Object,System.String,System.Boolean,System.Boolean)">
            <summary>
            Registers a method info on a target for callback later.
            </summary>
            <typeparam name="T">message Type</typeparam>
            <param name="target">handler object</param>
            <param name="methodName"> </param>
            <param name="background"> </param>
            <param name="holdReference"> </param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.RegisterJSCallback(StyleMVVM.Data.TypeWrapper,StyleMVVM.Messenger.JSCallback,System.Boolean)">
            <summary>
            Registers a JavaScript callback
            </summary>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.Unregister(System.Object)">
            <summary>
            Unregisters a consumer handler
            </summary>
            <param name="callback">action to unregister</param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.RegisterObjectHandlers(System.Object)">
            <summary>
            Allows you to register all methods on an object marked with MessageHandler attributes 
            </summary>
            <param name="handlerObject"></param>
        </member>
        <member name="M:StyleMVVM.Messenger.IDispatchedMessenger.UnregisterObjectHandlers(System.Object)">
            <summary>
            Allows you to unregister all methods on an object marked with MessageHandler attributes 
            </summary>
            <param name="handlerObject"></param>
        </member>
        <member name="P:StyleMVVM.Messenger.DispatchedMessenger.Instance">
            <summary>
            This the default implementation for IDispatchedMessenger resolved using the IoC container
            </summary>
        </member>
        <member name="M:StyleMVVM.Module.ModuleManager.RegisterExport(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Register ModuleManager with DI container.
            </summary>
            <param name="container"></param>
        </member>
        <member name="T:StyleMVVM.Notification.Badge.BadgeGlyph">
            <summary>
            This enumeration represents the different Glyphs that can be used to update the application Badge
            </summary>
        </member>
        <member name="T:StyleMVVM.Notification.Badge.IBadgeService">
            <summary>
            Service wrapper around the badge functionality
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Badge.IBadgeService.UdpateGlyph(StyleMVVM.Notification.Badge.BadgeGlyph)">
            <summary>
            Updates the badge for this application to the specified Glyph
            </summary>
            <param name="glyph"></param>
        </member>
        <member name="M:StyleMVVM.Notification.Badge.IBadgeService.UpdateNumber(System.Int32)">
            <summary>
            Update the badge for the current application to the specified number
            </summary>
            <param name="number"></param>
        </member>
        <member name="T:StyleMVVM.Notification.Tile.ITileUpdate">
            <summary>
            This interface represents a generic tile update.
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Tile.ITileUpdate.AddImageQuery">
            <summary>
            A flag weather to add a query string to the image URL
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Tile.ITileUpdate.Lang">
            <summary>
            Allows you to specify a particular language, null uses the local language
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Tile.ITileUpdate.BaseUri">
            <summary>
            Specifies the base URI for the update
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Tile.ITileUpdate.FallBack">
            <summary>
            Allows you to set a fallback template to use if the main template can't be found
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Tile.ITileUpdate.Branding">
            <summary>
            This specifies what type of branding to use when you update the tile
            </summary>
        </member>
        <member name="T:StyleMVVM.Notification.Tile.ITileService">
            <summary>
            This interface provides a wrapper around TileUpdater as well as providing an easy way to generate Tile updates
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.Clear">
            <summary>
            Clears the current tile information
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.GetScheduledTileNotifications">
            <summary>
            Returns a list of notifications that are scheduled for the main tile
            </summary>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.EnableNotificationQueue(System.Boolean)">
            <summary>
            Enabled notification queing for the TileUpdater
            </summary>
            <param name="enabled"></param>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.AddToSchedule(StyleMVVM.Notification.Tile.ITileUpdate,System.DateTimeOffset)">
            <summary>
            Schedules a tile update for the specified time offset
            </summary>
            <param name="update"></param>
            <param name="offSet"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.RemoveFromSchedule(Windows.UI.Notifications.ScheduledTileNotification)">
            <summary>
            Remove the specified tile notification
            </summary>
            <param name="notification"></param>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.StartPeriodicUpdate(System.Uri,Windows.UI.Notifications.PeriodicUpdateRecurrence)">
            <summary>
            Start a periodic tile update based on a uri and a recurrence period
            </summary>
            <param name="uri"></param>
            <param name="recurrence"></param>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.StartPeriodicUpdate(System.Uri,System.DateTimeOffset,Windows.UI.Notifications.PeriodicUpdateRecurrence)">
            <summary>
            Start a periodic tile update based on a provided uri, time offset and recurrence period
            </summary>
            <param name="uri"></param>
            <param name="startOffSet"></param>
            <param name="recurrence"></param>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.StopPeriodicUpdate">
            <summary>
            Stop all periodic updates for the main tile
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Tile.ITileService.Update(StyleMVVM.Notification.Tile.ITileUpdate)">
            <summary>
            Update the main application tile with the provided update
            </summary>
            <param name="update"></param>
        </member>
        <member name="T:StyleMVVM.Notification.Toast.IToastNotification">
            <summary>
            This interface represents a basic toast notification. 
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Toast.IToastNotification.GenerateXML">
            <summary>
            This method returns the XML for the notification string that should be between the visual tag
            </summary>
            <returns></returns>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.AddImageQuery">
            <summary>
            A flag weather to add a query string to the image URL
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.Lang">
            <summary>
            Allows you to specify a particular language, null uses the local language
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.BaseUri">
            <summary>
            Specifies the base URI for the update
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.FallBack">
            <summary>
            Allows you to set a fallback template to use if the main template can't be found
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.Branding">
            <summary>
            This specifies what type of branding to use when you update the tile
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.AudioSrc">
            <summary>
            You can specify an audio sound you want played when the toast is displayed
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.LoopAudio">
            <summary>
            Should the audio be looped till the toast is acknowledged
            </summary>
        </member>
        <member name="P:StyleMVVM.Notification.Toast.IToastNotification.MuteAudio">
            <summary>
            Mute any audio that is associated with the Toast (default is false)
            </summary>
        </member>
        <member name="T:StyleMVVM.Notification.Toast.IToastService">
            <summary>
            Represents a service that allows you to create Toast Notifications
            </summary>
        </member>
        <member name="M:StyleMVVM.Notification.Toast.IToastService.Toast(StyleMVVM.Notification.Toast.IToastNotification)">
            <summary>
            Sends a new Toast
            </summary>
            <param name="toast">new toast</param>
        </member>
        <member name="M:StyleMVVM.Suspension.FrameSuspensionManager.InternalSaveAsync">
            <summary>
            Save the current <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.  Any <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instances
            registered with <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> will also preserve their current
            navigation stack, which in turn gives their active <see cref="T:Windows.UI.Xaml.Controls.Page"/> an opportunity
            to save its state.
            </summary>
            <returns>An asynchronous task that reflects when session state has been saved.</returns>
        </member>
        <member name="M:StyleMVVM.Suspension.FrameSuspensionManager.InternalRestoreAsync">
            <summary>
            Restores previously saved <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.  Any <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instances
            registered with <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> will also restore their prior navigation
            state, which in turn gives their active <see cref="T:Windows.UI.Xaml.Controls.Page"/> an opportunity restore its
            state.
            </summary>
            <returns>An asynchronous task that reflects when session state has been read.  The
            content of <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/> should not be relied upon until this task
            completes.</returns>
        </member>
        <member name="M:StyleMVVM.Suspension.FrameSuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)">
            <summary>
            Registers a <see cref="T:Windows.UI.Xaml.Controls.Frame"/> instance to allow its navigation history to be saved to
            and restored from <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.  Frames should be registered once
            immediately after creation if they will participate in session state management.  Upon
            registration if state has already been restored for the specified key
            the navigation history will immediately be restored.  Subsequent invocations of
            <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RestoreAsync"/> will also restore navigation history.
            </summary>
            <param name="frame">An instance whose navigation history should be managed by
            <see cref="!:SuspensionManager"/></param>
            <param name="sessionStateKey">A unique key into <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/> used to
            store navigation-related information.</param>
        </member>
        <member name="M:StyleMVVM.Suspension.FrameSuspensionManager.UnregisterFrame(Windows.UI.Xaml.Controls.Frame)">
            <summary>
            Disassociates a <see cref="T:Windows.UI.Xaml.Controls.Frame"/> previously registered by <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/>
            from <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.  Any navigation state previously captured will be
            removed.
            </summary>
            <param name="frame">An instance whose navigation history should no longer be
            managed.</param>
        </member>
        <member name="M:StyleMVVM.Suspension.FrameSuspensionManager.SessionStateForFrame(Windows.UI.Xaml.Controls.Frame)">
            <summary>
            Provides storage for session state associated with the specified <see cref="T:Windows.UI.Xaml.Controls.Frame"/>.
            Frames that have been previously registered with <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RegisterFrame(Windows.UI.Xaml.Controls.Frame,System.String)"/> have
            their session state saved and restored automatically as a part of the global
            <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.  Frames that are not registered have transient state
            that can still be useful when restoring pages that have been discarded from the
            navigation cache.
            </summary>
            <remarks>Apps may choose to rely on <see cref="!:LayoutAwarePage"/> to manage
            page-specific state instead of working with frame session state directly.</remarks>
            <param name="frame">The instance for which session state is desired.</param>
            <returns>A collection of state subject to the same serialization mechanism as
            <see cref="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState"/>.</returns>
        </member>
        <member name="P:StyleMVVM.Suspension.FrameSuspensionManager.SessionState">
            <summary>
            Provides access to global session state for the current session.  This state is
            serialized by <see cref="!:SuspendAsync"/> and restored by
            <see cref="M:StyleMVVM.Suspension.FrameSuspensionManager.RestoreAsync"/>, so values must be serializable by
            <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> and should be as compact as possible.  Strings
            and other self-contained data types are strongly recommended.
            </summary>
        </member>
        <member name="P:StyleMVVM.Suspension.FrameSuspensionManager.KnownTypes">
            <summary>
            List of custom types provided to the <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> when
            reading and writing session state.  Initially empty, additional types may be
            added to customize the serialization process.
            </summary>
        </member>
        <member name="T:StyleMVVM.Utilities.ObjectSerializationHelper">
            <summary>
            This class provides serialization helpers that user the Json Data Contract serializer.
            </summary>
        </member>
        <member name="M:StyleMVVM.Validation.Impl.AttributeValidationProvider.RegisterExport(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Register AttributeValidationProvider with DI container.
            </summary>
            <param name="container">DI container</param>
        </member>
        <member name="M:StyleMVVM.Validation.Impl.ValidationService.RegisterExport(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Register ValidationService with DI container.
            </summary>
            <param name="container"></param>
        </member>
        <member name="P:StyleMVVM.ViewModel.INavigationParameterAwareViewModel.NavigationParameter">
            <summary>
            The NavigationParameter for the Page this ViewModel is associated with
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:StyleMVVM.View.SystemMessageBoxResult" -->
        <member name="T:StyleMVVM.ViewModel.DelegateCommand">
            <summary>
            A general implementation of ICommand used by ViewModels to bind to commands and events
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.EventCommand">
            <summary>
            This class can be used with Attached Event Commands as a handler. The benifit of using this class
            over DelegateCommand is that AEC is designed to send the sender,args and parameter to Execute
            where as DelegateCommand works with ICommand and only sends the parameter
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.IEventCommand">
            <summary>
            This interface is similar to ICommand only it passes the sender, args, and parameter
            it can't be used in Command="{Binding }" statements but rather with
            the AttachedEventCommand class
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.IEventCommand.Execute(System.Object,System.Object,System.Object)">
            <summary>
            Execute the command with the sender, args, and parameter
            </summary>
            <param name="sender">the event sender</param>
            <param name="args">event args</param>
            <param name="parameter">the bound parameter in AttachedEventCommand</param>
        </member>
        <member name="T:StyleMVVM.ViewModel.ILoadedAwareViewModel">
            <summary>
            ViewModels implement this interface when they want to
            hook into the FrameworkElement Loaded/Unloaded events
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.ILoadedAwareViewModel.OnLoaded(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Called when the view is Loaded
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.ILoadedAwareViewModel.OnUnloaded(System.Object,Windows.UI.Xaml.RoutedEventArgs)">
            <summary>
            Called when the view is Unloaded
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.Impl.ViewModelDataContextBinder">
            <summary>
            This class binds the ViewModel to the View.Data context property
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.IViewModelBinder">
            <summary>
            Any class that implements and export this interface will be included in the ViewModel binding process
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.IViewModelBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            This method will be called each time a ViewModel is being bound to a View
            </summary>
            <param name="frameworkElement">View object</param>
            <param name="viewModel">ViewModel object</param>
        </member>
        <member name="M:StyleMVVM.ViewModel.IViewModelBinder.UnbindViewModelFromView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            This method is called to unbind a ViewModel (Only happens when the ViewModel.Name property is changed after a view is constructed)
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelDataContextBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            Bind the ViewModel to the View's DataContext
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelDataContextBinder.UnbindViewModelFromView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            Remove the ViewModel from the View's DataContext
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:StyleMVVM.ViewModel.Impl.ViewModelLoadedBinder" -->
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelLoadedBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the viewmodel implements ILoadedAwareViewModel interfacce then event handlers are connected to the View 
            and fire the Loaded and Unloaded handlers on the ViewModel
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.Impl.ViewModelNavigationBinder">
            <summary>
            This class binds the navigation events of the view to the viewmodels Navigation handlers
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelNavigationBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the view implements INavigatingPage and the ViewModel implements the INavigationViewModel interface
            then event handlers will be hooked up to the View's navigations events
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelNavigationBinder.UnbindViewModelFromView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the view implements INavigatingPage and the ViewModel implements the INavigationViewModel interface
            then event handlers will be removed from the View's navigations events
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.Impl.ViewModelParentDataContextBinder">
            <summary>
            This class bind the Parents View's DataContext to the current ViewModel
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelParentDataContextBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the viewModel implements the IParentDataContextAwareViewModel interface then the Parent View's DataContext
            will be set to the ViewModel.ParentDataContext property at view load time
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelParentDataContextBinder.UnbindViewModelFromView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            if the view model implements the IParentDataContextAwareViewModel interface then the parents view will be disconnected.
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.Impl.ViewModelResolutionService">
            <summary>
            This class is responsible or resolving and binding all viewmodels
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.IViewModelResolutionService">
            <summary>
            The IViewModelResolutionService is responsible for resolving and binding viewmodels to views.
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.IViewModelResolutionService.ResolveViewModel(Windows.UI.Xaml.FrameworkElement,System.String)">
            <summary>
            This method resolves a viewmodel for a view and binds it.
            </summary>
            <param name="view"></param>
            <param name="viewModelName"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelResolutionService.RegisterExport(StyleMVVM.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Export this class as an IViewModelResolutionService
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelResolutionService.ImportBinders(System.Collections.Generic.IEnumerable{StyleMVVM.ViewModel.IViewModelBinder})">
            <summary>
            Import all known model binders, called during activation
            </summary>
            <param name="binderCollection">all known model binders</param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelResolutionService.ResolveViewModel(Windows.UI.Xaml.FrameworkElement,System.String)">
            <summary>
            Creates and Binds a viewmodel to a view
            </summary>
            <param name="view">view to bind to</param>
            <param name="viewModelName">name of the view model to bind to</param>
        </member>
        <member name="P:StyleMVVM.ViewModel.Impl.ViewModelResolutionService.Container">
            <summary>
            Container to use for resolving models
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.Impl.ViewModelViewAwareBinder">
            <summary>
            This class binds the View property for IViewAware interface when implemented in a ViewModel
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelViewAwareBinder.BindViewModelToView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the viewmodel implements IViewAware then the View property is set.
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.Impl.ViewModelViewAwareBinder.UnbindViewModelFromView(Windows.UI.Xaml.FrameworkElement,System.Object)">
            <summary>
            If the view model implements IViewAware then the View property is unset
            </summary>
            <param name="frameworkElement"></param>
            <param name="viewModel"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.INavigationViewModel">
            <summary>
            This interfaces is implemented by ViewModels that are interested
            in page Navigation (use only as ViewModels for Page Views)
            </summary>
        </member>
        <member name="M:StyleMVVM.ViewModel.INavigationViewModel.NavigatedTo(System.Object,StyleMVVM.View.StyleNavigationEventArgs)">
            <summary>
            Called when the Page is Navigated To
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.INavigationViewModel.NavigatedFrom(System.Object,StyleMVVM.View.StyleNavigationEventArgs)">
            <summary>
            Called when the PAge is navigated from
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:StyleMVVM.ViewModel.INavigationViewModel.NavigatingFrom(System.Object,StyleMVVM.View.StyleNavigatingCancelEventArgs)">
            <summary>
            Called directly before the page is navigated away from
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:StyleMVVM.ViewModel.IParentDataContextAwareViewModel">
            <summary>
            ViewModels that wish to know what the data context is for the parent view can implement this interface and ParentDataContext will
            be populated when the view is loaded into the visual tree.
            </summary>
        </member>
        <member name="P:StyleMVVM.ViewModel.IParentDataContextAwareViewModel.ParentDataContext">
            <summary>
            The Data Context associated with the parent View for this view model
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.IPopupViewModel">
            <summary>
            
            </summary>
        </member>
        <member name="T:StyleMVVM.ViewModel.IViewAware">
            <summary>
            This interface is implemented by ViewModels that need access to the
            view they are associated to
            </summary>
        </member>
        <member name="P:StyleMVVM.ViewModel.IViewAware.View">
            <summary>
            The view this viewmodel is associated with
            </summary>
        </member>
        <member name="T:StyleMVVM.View.BusyIndicator">
            <summary>
            A control to provide a visual indicator when an application is busy.
            </summary>
            <QualityBand>Preview</QualityBand>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator._displayAfterTimer">
            <summary>
            Timer used to delay the initial display and avoid flickering.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.#ctor">
            <summary>
            Instantiates a new instance of the BusyIndicator control.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.OnApplyTemplate">
            <summary>
            Overrides the OnApplyTemplate method.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.DisplayAfterTimerElapsed(System.Object,System.Object)">
            <summary>
            Handler for the DisplayAfterTimer.
            </summary>
            <param name="sender">Event sender.</param>
            <param name="e">Event arguments.</param>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.ChangeVisualState(System.Boolean)">
            <summary>
            Changes the control's visual state(s).
            </summary>
            <param name="useTransitions">True if state transitions should be used.</param>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalIsBusyProperty">
            <summary>
            Identifies the IsBusy dependency property.
            </summary>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.OnIsBusyChanged(Windows.UI.Xaml.DependencyObject,Windows.UI.Xaml.DependencyPropertyChangedEventArgs)">
            <summary>
            IsBusyProperty property changed handler.
            </summary>
            <param name="d">BusyIndicator that changed its IsBusy.</param>
            <param name="e">Event arguments.</param>
        </member>
        <member name="M:StyleMVVM.View.BusyIndicator.OnIsBusyChanged(Windows.UI.Xaml.DependencyPropertyChangedEventArgs)">
            <summary>
            IsBusyProperty property changed handler.
            </summary>
            <param name="e">Event arguments.</param>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalBusyContentProperty">
            <summary>
            Identifies the BusyContent dependency property.
            </summary>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalBusyContentTemplateProperty">
            <summary>
            Identifies the BusyTemplate dependency property.
            </summary>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalDisplayAfterProperty">
            <summary>
            Identifies the DisplayAfter dependency property.
            </summary>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalOverlayStyleProperty">
            <summary>
            Identifies the OverlayStyle dependency property.
            </summary>
        </member>
        <member name="F:StyleMVVM.View.BusyIndicator.InternalProgressBarStyleProperty">
            <summary>
            Identifies the ProgressBarStyle dependency property.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.IsContentVisible">
            <summary>
            Gets or sets a value indicating whether the BusyContent is visible.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.IsBusy">
            <summary>
            Gets or sets a value indicating whether the busy indicator should show.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.BusyContent">
            <summary>
            Gets or sets a value indicating the busy content to display to the user.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.BusyContentTemplate">
            <summary>
            Gets or sets a value indicating the template to use for displaying the busy content to the user.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.DisplayAfter">
            <summary>
            Gets or sets a value indicating how long to delay before displaying the busy content.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.OverlayStyle">
            <summary>
            Gets or sets a value indicating the style to use for the overlay.
            </summary>
        </member>
        <member name="P:StyleMVVM.View.BusyIndicator.ProgressBarStyle">
            <summary>
            Gets or sets a value indicating the style to use for the progress bar.
            </summary>
        </member>
        <member name="T:StyleMVVM.View.CharmOrientation">
            <summary>
            This enumeration defines the different ways the charm can be oriented to the screen
            </summary>
        </member>
        <member name="T:StyleMVVM.View.ICharmInfo">
            <summary>
            Classes that implement and export this interface will be used to create Setting Pane configuration
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.CharmId">
            <summary>
            This is the unique id the charm will be known by (incase you want to activate it indepent of the setting pane)
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.ExportName">
            <summary>
            This is the name of the View to use when the charm is activated (usually a View that inherits from CharmControl)
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.SettingsText">
            <summary>
            This is the text that is displayed in the setting pane
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.ShowInAppSettings">
            <summary>
            This property specifies if the charm should be listed in the Settings Pane (true by default)
            Note: This called each time the Settings Pane is opened
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.CharmSize">
            <summary>
            This is either the width or height of the Charm based upon orientation
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.Orientation">
            <summary>
            This is the orientation of the charm by default it is CharmOrientation
            </summary>
        </member>
        <member name="P:StyleMVVM.View.ICharmInfo.TransitionPopup">
            <summary>
            This specifies if the popup should transition its content. (false by default)
            For Settings charm it is recommended that this is false.
            </summary>
        </member>
        <member name="T:StyleMVVM.View.ICharmService">
            <summary>
            This is the service that controls the creation of the settings pane and activates charms
            </summary>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.RegisterCharmNotify(System.String,StyleMVVM.View.CharmNotification)">
            <summary>
            Creates a new entry in the Settings Pane and invokes notification delegate upon user selection
            </summary>
            <param name="charmName">display string for charm</param>
            <param name="notification">charm callback</param>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.RegisterCharmNotify(System.String,StyleMVVM.View.CharmNotification,StyleMVVM.View.ShowCharm)">
            <summary>
            Creates a new entry in the SettingsPane and invokes notification delegate upon user selection
            </summary>
            <param name="charmName">display string for the charm</param>
            <param name="notification">callback delegate for when the user select the charm</param>
            <param name="showCharm">delegate allows you to enable and disable charm at the point when the SettingsPane is shown</param>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.UnRegisterCharmNotify(System.String)">
            <summary>
            Removes the charm specified from the SettingsPabe
            </summary>
            <param name="charmName"></param>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.OpenCharm(System.String)">
            <summary>
            Opens a new charm of the specified name
            </summary>
            <param name="charmName"></param>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.OpenCharm(System.String,System.Object)">
            <summary>
            Opens a new charm of the specified name
            </summary>
            <param name="charmName"></param>
            <param name="navigationParameter"></param>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.Back">
            <summary>
            Move back in the charm stack (if ther are no more in the stack then SettingsPane is opened)
            </summary>
        </member>
        <member name="M:StyleMVVM.View.ICharmService.CloseCharm">
            <summary>
            Close the open charm
            </summary>
        </member>
        <member name="T:StyleMVVM.View.IFilePickerService">
            <summary>
            The IFilePickerService acts as a wrapper around the default file picker class
            </summary>
        </member>
        <member name="M:StyleMVVM.View.IFilePickerService.PickMultipleFilesAsync(Windows.Storage.Pickers.PickerLocationId,System.String[])">
            <summary>
            Opens a file picker and allows the user to pick multiple files and return a list of the files the user chose
            </summary>
            <param name="location"></param>
            <param name="filterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.View.IFilePickerService.PickFileAsync(Windows.Storage.Pickers.PickerLocationId,System.String[])">
            <summary>
            Opens a file picker and allows the user to pick one file and returns a StorageFile to the caller
            </summary>
            <param name="location"></param>
            <param name="filterTypes"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.View.IMessageBoxService">
            <summary>
            This service gives you easy access to the MessageDialog class as well as creates IMessageDialog wrappers
            </summary>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.Notify(System.String)">
            <summary>
            Opens a message box to the user with just the ok button
            </summary>
            <param name="message">message to display to the user</param>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.Notify(System.String,System.String)">
            <summary>
            Opens a message box to the user with just the ok button
            </summary>
            <param name="message">message to display to the user</param>
            <param name="title">title on the message box</param>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.Show(System.String)">
            <summary>
            Show a new message dialog
            </summary>
            <param name="message"></param>
            <returns>returns the command clicked</returns>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.Show(System.String,System.String,System.String[])">
            <summary>
            Show a new message dialog with the specified title and commands
            </summary>
            <param name="message">message to display</param>
            <param name="title">title for the message dialog</param>
            <param name="commands">command to show in the dialog</param>
            <returns>returns the command that was clicked</returns>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.MessageDialog(System.String,System.String)">
            <summary>
            Creates a new message Dialog object that can be configured then shown
            </summary>
            <param name="message">message for the dialog</param>
            <param name="title">title for the dialog</param>
            <returns>returns a new message dialog object that you configure then show</returns>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.ShowSystemMessageBox(System.String)">
            <summary>
            Show a new message dialog
            </summary>
            <param name="message"></param>
            <returns>returns the command clicked</returns>
        </member>
        <member name="M:StyleMVVM.View.IMessageBoxService.ShowSystemMessageBox(System.String,System.String,StyleMVVM.View.SystemMessageBoxButton)">
            <summary>
            Show a new message dialog with the specified title and commands
            </summary>
            <param name="message">message to display</param>
            <param name="title">title for the message dialog</param>
            <param name="commands">command to show in the dialog</param>
            <returns>returns the command that was clicked</returns>
        </member>
        <member name="T:StyleMVVM.View.IMessageDialog">
            <summary>
            This interface represnets a wrapper around MessageDialog class
            </summary>
        </member>
        <member name="M:StyleMVVM.View.IMessageDialog.AddCommand(System.String,System.Object)">
            <summary>
            Adds a new command to the message dialog
            </summary>
            <param name="command">new command string (displayed to user)</param>
            <param name="commandAction">Action(string) to execute</param>
            <returns>returns self</returns>
        </member>
        <member name="M:StyleMVVM.View.IMessageDialog.AddCommand(System.String,System.Boolean,System.Object)">
            <summary>
            Adds a new command to the message dialog 
            </summary>
            <param name="command"></param>
            <param name="defaultCommand"></param>
            <param name="commandAction"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.View.Impl.FauxNavigationService">
            <summary>
            This is a 
            </summary>
        </member>
        <member name="T:StyleMVVM.View.INavigationService">
            <summary>
            Represents an object that can Navigate a frame within the app.
            At Runtime this just wraps a Frame class, at UnitTest Time this is 
            substituted for something else
            </summary>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.GoHome">
            <summary>
            Navigate Home if possible
            </summary>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.GoBack">
            <summary>
            Navigate Back if possible
            </summary>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.GoForward">
            <summary>
            Navigate forward if possible
            </summary>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.Navigate(System.String)">
            <summary>
            Navigate to a new page by name
            </summary>
            <param name="pageName">name of the page (usually class name)</param>
            <param name="navigationParam">navigation parameter</param>
            <returns>true if it could navigate to said page</returns>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.Navigate(System.Type)">
            <summary>
            Navigate to a new page By Type
            </summary>
            <param name="pageType">new page type</param>
            <param name="navigationParam">navigation parameter</param>
            <returns>true if it could navigate to said page</returns>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.Navigate(System.String,System.Object)">
            <summary>
            Navigate to a new page by name
            </summary>
            <param name="pageName">name of the page (usually class name)</param>
            <param name="navigationParam">navigation parameter</param>
            <returns>true if it could navigate to said page</returns>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.Navigate(System.Type,System.Object)">
            <summary>
            Navigate to a new page By Type
            </summary>
            <param name="pageType">new page type</param>
            <param name="navigationParam">navigation parameter</param>
            <returns>true if it could navigate to said page</returns>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.OpenOverlay(System.String)">
            <summary>
            Open an overlay on a Page
            </summary>
            <param name="overlayName">export name of overlay</param>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.OpenOverlay(System.String,System.Object)">
            <summary>
            Open an overlay on a Page
            </summary>
            <param name="overlayName">export name of overlay</param>
            <param name="context"> </param>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.ReplaceOverlay(System.String)">
            <summary>
            Replace the current overlay with a new overlay
            </summary>
            <param name="newOverlayName"></param>
            <param name="context"> </param>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.ReplaceOverlay(System.String,System.Object)">
            <summary>
            Replace the current overlay with a new overlay
            </summary>
            <param name="newOverlayName"></param>
            <param name="context"> </param>
        </member>
        <member name="M:StyleMVVM.View.INavigationService.CloseOverlay">
            <summary>
            Close the current overlay
            </summary>
        </member>
        <member name="P:StyleMVVM.View.INavigationService.IsValid">
            <summary>
            Is the navigation service currently valid
            </summary>
        </member>
        <member name="P:StyleMVVM.View.INavigationService.CanGoBack">
            <summary>
            Can the service navigate back
            </summary>
        </member>
        <member name="P:StyleMVVM.View.INavigationService.CanGoForward">
            <summary>
            Can the service navigate forward
            </summary>
        </member>
        <member name="P:StyleMVVM.View.INavigationService.OverlayOpen">
            <summary>
            Is there an open overlay on this page
            </summary>
        </member>
        <member name="T:StyleMVVM.View.Impl.NavigationService">
            <summary>
            Default implementation of INavigationService
            </summary>
        </member>
        <member name="T:StyleMVVM.View.IUIVisualizationService">
            <summary>
            The UIVisualization Service offers the ability to open popups and popup menus
            </summary>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.UI.Xaml.FrameworkElement,System.String)">
            <summary>
            Opens a popup View over the specified FrameworkElement
            </summary>
            <param name="control"></param>
            <param name="viewName"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.UI.Xaml.FrameworkElement,System.String,System.Object)">
            <summary>
            Opens a new Popup View over the specified FrameworkElement using the supplied navigation parameter
            </summary>
            <param name="control"></param>
            <param name="viewName"></param>
            <param name="navigationParameter"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.UI.Xaml.FrameworkElement,System.String,System.Object,System.Boolean,StyleMVVM.Data.ICancellationToken,StyleMVVM.View.RelativePosition,Windows.Foundation.Point)">
            <summary>
            Opens a new Popup View and allows you to control all aspects of how the popup is opened
            </summary>
            <param name="control"></param>
            <param name="viewName"></param>
            <param name="navigationParameter"></param>
            <param name="isLightDismissEnabled"></param>
            <param name="cancellationToken"></param>
            <param name="position"></param>
            <param name="offset"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.Foundation.Point,System.String)">
            <summary>
            Opens a new poup at the specified point
            </summary>
            <param name="point"></param>
            <param name="viewName"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.Foundation.Point,System.String,System.Object)">
            <summary>
            Opens a new Popup at the specified point using the provided navigation parameter
            </summary>
            <param name="point"></param>
            <param name="viewName"></param>
            <param name="navigationParameter"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.Popup(Windows.Foundation.Point,System.String,System.Object,System.Boolean,StyleMVVM.Data.ICancellationToken)">
            <summary>
            Opens a new Popup allowing the caller to control all aspects of how the popup is opened
            </summary>
            <param name="point"></param>
            <param name="viewName"></param>
            <param name="navigationParameter"></param>
            <param name="isLightDismissEnabled"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.PopupMenu(Windows.UI.Xaml.FrameworkElement,System.String[])">
            <summary>
            Opens a new popup menu over the specified control
            </summary>
            <param name="control"></param>
            <param name="menuOptions"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.PopupMenu(Windows.UI.Xaml.FrameworkElement,StyleMVVM.View.RelativePosition,Windows.Foundation.Point,System.String[])">
            <summary>
            Opens a new popup menu relative the provided FrameworkElement
            </summary>
            <param name="control"></param>
            <param name="position"></param>
            <param name="offset"></param>
            <param name="menuOptions"></param>
            <returns></returns>
        </member>
        <member name="M:StyleMVVM.View.IUIVisualizationService.PopupMenu(Windows.Foundation.Point,System.String[])">
            <summary>
            Opens a new popup menu at the provided spot with the specified menu options
            </summary>
            <param name="point"></param>
            <param name="menuOptions"></param>
            <returns></returns>
        </member>
        <member name="T:StyleMVVM.View.INavigatingPage">
            <summary>
            This interface needs to be implemented in a Page if the viewmodel 
            is to have full navigation access.
            </summary>
        </member>
        <member name="E:StyleMVVM.View.INavigatingPage.NavigatedTo">
            <summary>
            NavigatedTo event that is called when Page calls OnNavigatedTo
            </summary>
        </member>
        <member name="E:StyleMVVM.View.INavigatingPage.NavigatedFrom">
            <summary>
            NavigatedFrom event that is called when Page calls OnNavigatedFrom
            </summary>
        </member>
        <member name="E:StyleMVVM.View.INavigatingPage.NavigatingFrom">
            <summary>
            NavigatingFrom event that is called when Page calls OnNavigatingFrom
            </summary>
        </member>
        <member name="T:StyleMVVM.View.Region">
            <summary>
            This class is to help bind XAML and the Region Manager.
            </summary>
        </member>
        <member name="T:StyleMVVM.View.Regions.BaseRegion">
            <summary>
            This is the base implementation of IRegion.
            </summary>
        </member>
        <member name="T:StyleMVVM.View.SystemMessageBoxButton">
            <summary>
            This enumeration represents the possible buttons you can use for a system message box.
            Note: Windows Phone 8 only offers Ok and OkCancel.
            </summary>
        </member>
        <member name="T:StyleMVVM.View.ViewModel">
            <summary>
            This class offers Dependency properties that allow you to bind a ViewModel
            to a Views DataContext by setting the Name property in XAML
            </summary>
        </member>
        <member name="M:StyleMVVM.View.ViewModel.GetName(Windows.UI.Xaml.DependencyObject)">
            <summary>
            Gets the name of the ViewModel for the specified view
            </summary>
            <param name="obj">the view</param>
            <returns>the ViewModel Name</returns>
        </member>
        <member name="M:StyleMVVM.View.ViewModel.SetName(Windows.UI.Xaml.DependencyObject,System.String)">
            <summary>
            Sets the ViewModel name for the provided View
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="F:StyleMVVM.View.ViewModel.InternalNameProperty">
            <summary>
            Assigns a ViewModel Name to a View and is the Linkage that connects the
            ViewModel to the Views data context (Done at name change)
            </summary>
        </member>
    </members>
</doc>
